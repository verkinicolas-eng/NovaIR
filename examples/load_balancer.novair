# Load Balancer
# Distributes work across multiple processing lanes

system LoadBalancer @version("1.0")

state:
  cpu_usage <- metrics.cpu.percent
  memory_usage <- metrics.memory.percent
  queue_depth <- metrics.queue.depth
  active_lanes <- cluster.lanes.count
  latency_p95 <- metrics.latency.p95

constraints:
  cpu_max : cpu_usage <= 85 @critical
  memory_max : memory_usage <= 80 @critical
  queue_overflow : queue_depth <= 10000 @critical
  latency_sla : latency_p95 <= 100 @warning

objectives:
  throughput : queue_depth -> min @priority(10)
  low_latency : latency_p95 -> target(50) @priority(9)
  queue_empty : queue_depth -> target(100) @priority(6)
  resource_efficient : cpu_usage -> target(60) @priority(4)

actions:
  scale_up:
    parameters: [lanes: 1..4]
    effects:
      active_lanes: +1 to +4
      cpu_usage: +10 to +40
      queue_depth: -500 to -2000
    cost: high

  scale_down:
    parameters: [lanes: 1..3]
    effects:
      active_lanes: -1 to -3
      cpu_usage: -8 to -24
    cost: low

  throttle:
    effects:
      cpu_usage: -15
      latency_p95: +20
    cost: medium

  shed_load:
    effects:
      queue_depth: -30
      cpu_usage: -20
    cost: high

  free_cache:
    effects:
      memory_usage: -15
      latency_p95: +5
    cost: low

tick:
  interval: 200 ms
  action_threshold: 0.5
  mode: continuous
